"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
var node_fs_1 = require("node:fs");
var node_path_1 = require("node:path");
var node_url_1 = require("node:url");
var schema_js_1 = require("../src/gateway/protocol/schema.js");
var __dirname = node_path_1.default.dirname((0, node_url_1.fileURLToPath)(import.meta.url));
var repoRoot = node_path_1.default.resolve(__dirname, "..");
var outPaths = [
    node_path_1.default.join(repoRoot, "apps", "macos", "Sources", "OpenClawProtocol", "GatewayModels.swift"),
    node_path_1.default.join(repoRoot, "apps", "shared", "OpenClawKit", "Sources", "OpenClawProtocol", "GatewayModels.swift"),
];
var header = "// Generated by scripts/protocol-gen-swift.ts \u2014 do not edit by hand\nimport Foundation\n\npublic let GATEWAY_PROTOCOL_VERSION = ".concat(schema_js_1.PROTOCOL_VERSION, "\n\npublic enum ErrorCode: String, Codable, Sendable {\n").concat(Object.values(schema_js_1.ErrorCodes)
    .map(function (c) { return "    case ".concat(camelCase(c), " = \"").concat(c, "\""); })
    .join("\n"), "\n}\n");
var reserved = new Set([
    "associatedtype",
    "class",
    "deinit",
    "enum",
    "extension",
    "fileprivate",
    "func",
    "import",
    "init",
    "inout",
    "internal",
    "let",
    "open",
    "operator",
    "private",
    "precedencegroup",
    "protocol",
    "public",
    "rethrows",
    "static",
    "struct",
    "subscript",
    "typealias",
    "var",
]);
function camelCase(input) {
    return input
        .replace(/[^a-zA-Z0-9]+/g, " ")
        .trim()
        .toLowerCase()
        .split(/\s+/)
        .map(function (p, i) { return (i === 0 ? p : p[0].toUpperCase() + p.slice(1)); })
        .join("");
}
function safeName(name) {
    var cc = camelCase(name.replace(/-/g, "_"));
    if (reserved.has(cc)) {
        return "_".concat(cc);
    }
    return cc;
}
// filled later once schemas are loaded
var schemaNameByObject = new Map();
function swiftType(schema, required) {
    var _a;
    var t = schema.type;
    var isOptional = !required;
    var base;
    var named = schemaNameByObject.get(schema);
    if (named) {
        base = named;
    }
    else if (t === "string") {
        base = "String";
    }
    else if (t === "integer") {
        base = "Int";
    }
    else if (t === "number") {
        base = "Double";
    }
    else if (t === "boolean") {
        base = "Bool";
    }
    else if (t === "array") {
        base = "[".concat(swiftType((_a = schema.items) !== null && _a !== void 0 ? _a : { type: "Any" }, true), "]");
    }
    else if (schema.enum) {
        base = "String";
    }
    else if (schema.patternProperties) {
        base = "[String: AnyCodable]";
    }
    else if (t === "object") {
        base = "[String: AnyCodable]";
    }
    else {
        base = "AnyCodable";
    }
    return isOptional ? "".concat(base, "?") : base;
}
function emitStruct(name, schema) {
    var _a, _b;
    var props = (_a = schema.properties) !== null && _a !== void 0 ? _a : {};
    var required = new Set((_b = schema.required) !== null && _b !== void 0 ? _b : []);
    var lines = [];
    lines.push("public struct ".concat(name, ": Codable, Sendable {"));
    if (Object.keys(props).length === 0) {
        lines.push("}\n");
        return lines.join("\n");
    }
    var codingKeys = [];
    for (var _i = 0, _c = Object.entries(props); _i < _c.length; _i++) {
        var _d = _c[_i], key = _d[0], propSchema = _d[1];
        var propName = safeName(key);
        var propType = swiftType(propSchema, required.has(key));
        lines.push("    public let ".concat(propName, ": ").concat(propType));
        if (propName !== key) {
            codingKeys.push("        case ".concat(propName, " = \"").concat(key, "\""));
        }
        else {
            codingKeys.push("        case ".concat(propName));
        }
    }
    lines.push("\n    public init(\n" +
        Object.entries(props)
            .map(function (_a) {
            var key = _a[0], prop = _a[1];
            var propName = safeName(key);
            var req = required.has(key);
            return "        ".concat(propName, ": ").concat(swiftType(prop, true)).concat(req ? "" : "?");
        })
            .join(",\n") +
        "\n    ) {\n" +
        Object.entries(props)
            .map(function (_a) {
            var key = _a[0];
            var propName = safeName(key);
            return "        self.".concat(propName, " = ").concat(propName);
        })
            .join("\n") +
        "\n    }\n" +
        "    private enum CodingKeys: String, CodingKey {\n" +
        codingKeys.join("\n") +
        "\n    }\n}");
    lines.push("");
    return lines.join("\n");
}
function emitGatewayFrame() {
    var cases = ["req", "res", "event"];
    var associated = {
        req: "RequestFrame",
        res: "ResponseFrame",
        event: "EventFrame",
    };
    var caseLines = cases.map(function (c) { return "    case ".concat(safeName(c), "(").concat(associated[c], ")"); });
    var initLines = "\n    private enum CodingKeys: String, CodingKey {\n        case type\n    }\n\n    public init(from decoder: Decoder) throws {\n        let typeContainer = try decoder.container(keyedBy: CodingKeys.self)\n        let type = try typeContainer.decode(String.self, forKey: .type)\n        switch type {\n        case \"req\":\n            self = .req(try RequestFrame(from: decoder))\n        case \"res\":\n            self = .res(try ResponseFrame(from: decoder))\n        case \"event\":\n            self = .event(try EventFrame(from: decoder))\n        default:\n            let container = try decoder.singleValueContainer()\n            let raw = try container.decode([String: AnyCodable].self)\n            self = .unknown(type: type, raw: raw)\n        }\n    }\n\n    public func encode(to encoder: Encoder) throws {\n        switch self {\n        case .req(let v): try v.encode(to: encoder)\n        case .res(let v): try v.encode(to: encoder)\n        case .event(let v): try v.encode(to: encoder)\n        case .unknown(_, let raw):\n            var container = encoder.singleValueContainer()\n            try container.encode(raw)\n        }\n    }\n";
    return __spreadArray(__spreadArray([
        "public enum GatewayFrame: Codable, Sendable {"
    ], caseLines, true), [
        "    case unknown(type: String, raw: [String: AnyCodable])",
        initLines,
        "}",
        "",
    ], false).join("\n");
}
function generate() {
    return __awaiter(this, void 0, void 0, function () {
        var definitions, _i, definitions_1, _a, name_1, schema, parts, _b, definitions_2, _c, name_2, schema, content, _d, outPaths_1, outPath;
        return __generator(this, function (_e) {
            switch (_e.label) {
                case 0:
                    definitions = Object.entries(schema_js_1.ProtocolSchemas);
                    for (_i = 0, definitions_1 = definitions; _i < definitions_1.length; _i++) {
                        _a = definitions_1[_i], name_1 = _a[0], schema = _a[1];
                        schemaNameByObject.set(schema, name_1);
                    }
                    parts = [];
                    parts.push(header);
                    // Value structs
                    for (_b = 0, definitions_2 = definitions; _b < definitions_2.length; _b++) {
                        _c = definitions_2[_b], name_2 = _c[0], schema = _c[1];
                        if (name_2 === "GatewayFrame") {
                            continue;
                        }
                        if (schema.type === "object") {
                            parts.push(emitStruct(name_2, schema));
                        }
                    }
                    // Frame enum must come after payload structs
                    parts.push(emitGatewayFrame());
                    content = parts.join("\n");
                    _d = 0, outPaths_1 = outPaths;
                    _e.label = 1;
                case 1:
                    if (!(_d < outPaths_1.length)) return [3 /*break*/, 5];
                    outPath = outPaths_1[_d];
                    return [4 /*yield*/, node_fs_1.promises.mkdir(node_path_1.default.dirname(outPath), { recursive: true })];
                case 2:
                    _e.sent();
                    return [4 /*yield*/, node_fs_1.promises.writeFile(outPath, content)];
                case 3:
                    _e.sent();
                    console.log("wrote ".concat(outPath));
                    _e.label = 4;
                case 4:
                    _d++;
                    return [3 /*break*/, 1];
                case 5: return [2 /*return*/];
            }
        });
    });
}
generate().catch(function (err) {
    console.error(err);
    process.exit(1);
});
